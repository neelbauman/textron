stateのリフトアップ
===============================
しばしば、いくつかのコンポーネントが、同一の変化するデータを反映する必要が在る場合がある。そんなときは、最も近い共通の祖先コンポーネントへ共有されているstateをリフトアップすることを推奨している。

**与えられた温度で水が沸騰するかどうかを計算する温度計算ソフトウェアを作成する。**

アプリケーション
-----------------------------------------
.. raw:: html

    <div id="root"></div>
    <script type="text/javascript" async src="../../_static/tech/React/liftup.js"></script>


解説
-----------------------------------------
このように、どちらの入力コンポーネントを編集したかに関わらず、Calculatorのthis.state.temperatureとthis.state.scaleが更新される。片方の入力コンポーネントは、ユーザからのあらゆる入力が保持されるように値をそのまま受け取り、もう片方の入力コンポーネントの値はそれに基づいて常に再計算される。

入力値の変更が起こった際に起こる一連の流れ：

1. Reactは、DOMの<input>でonChangeとして指定された関数を呼び出す。この場合、TemperatureInputのhandleChangeメソッドである。
2. TemperatureInputのhandleChangeメソッドは、this.props.onTemperatureChange()に引数を渡しながら呼び出す。onTemperatureChangeを含むpropsは親コンポーネントとなるCalculatorから渡される。
3. レンダー時、Calculatorは摂氏のTemperatureInputのonTemperatureChangeには自身のhandleCelsiusChangeメソッドを指定し、華氏のTemperatureInputのonTemperatureChangeには自身のhandleFahrenheitChangeを指定していた。そのため、どちらの入力フィイールドを編集したかによって、２つのCalculatorメソッドのうちのどちらが呼び出されるかが決まる。
4. これらのメソッド内では、Calculatorコンポーネントが新しい入力値と更新したほうの入力値の単位をthis.setState()に与えて呼び出して、ReactにCalculatorコンポーネント自身を再レンダーさせる。
5. ReactはCalculatorコンポーネントのrenderメソッドを呼び出して、UIがどのような見た目になるべきかを把握する。両方の入力コンポーネントの値が現在の温度とアクティブな単位に基づいて再計算される。温度の変換処理はこのタイミングで行われる。
6. ReactはCalculatorにより与えられた新しいpropsで各TemperatureInputのrenderメソッドを呼び出す。ReactはそれらのUIがどのような見た目になるのかを理解する。
7. React DOMは沸騰したかの判定結果と入力コンポーネントの値によって、DOMを更新する。変更された入力コンポーネントは現在の値によってもう一方の入力コンポーネントは変換された温度によって更新される。

全ての更新は同じ手順で実行され、このようにして２つの入力コンポーネントは常に同期されている状態を保つ。

この章でまなんだこと
----------------------------------------------
Reactアプリケーションで変化するどのようなデータも、単一の”信頼できる情報源”であるべきである。通常、stateはレンダー時にそれを必要とするコンポーネントに最初に追加される。それから他のコンポーネントもそのstateを必要としていて、それらの間に同期された振る舞いを要請する必要があるならば、直近の親コンポーネントにそのstateをリフトアップすることができる。異なるコンポーネント間でstateを同期しようとする代わりに、トップダウン型のデータフローの力をりようするべきである。

| stateのリフトアップは、双方向のデータバインディングを行う方法よりも多くのポイラープレートコードを生み出すが、その効果としてバグを発見して切り出す作業が少なくて済むようになる。あらゆるstateはいずれかのコンポーネント内に存在し、そのコンポーネントのみがそのstateを変更できるので、バグが潜む範囲は大幅に削減される。また、ユーザ入力を拒否したり変換したりする任意の独自ロジックを各コンポーネントに実装することもできる。

|
| propsもしくはstateから派生的に作り出すことのできるデータについては、おそらく、stateに保持するべきではないだろう。たとえば、今回はcelsiusValueとfahrenheitValueの両方を保持する代わりに、最後に変更されたtemperatureとその値のscaleのみを保存している。もう一方の入力の値は常にrender()メソッド内で計算することができる。これにより、もとのユーザ入力の精度を全く損なうことなくもう一方の入力フィールドに丸めを適用したり、もう一方の入力フィールドをクリアしたりできる。

|
| これはつまるところ、オブジェクト指向やカプセル化の原理の一つであるところの、オブジェクト自身が保持する値は本質的なもの（あるいは同値類の代表元ひとつ）だけとし、本質的に等価で表現が異なるにすぎないものについてはその変換により対応する、という原理を強調しているに過ぎない。
