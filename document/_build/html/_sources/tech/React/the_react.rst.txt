Reactの流儀
=====================================

ここでは、検索可能な商品データ表をReactで作っていく様子を通して、Reactのアプリケーション開発の流儀（そして後に分かるようにここでの考え方は、Reactのみならず、高度にモジュール化されたアプリケーション開発全般について応用可能である）を学んでいこう。

モックから始めよう
-------------------------------------
すでにJSON APIが実装済みで、デザイナーからもデザインモックがもらえているとする。JSON APIは、次のようなデータを返してくるとする。

.. code-block:: json

    [
        {category: "Sporting Goods", price: "$49.99", stocked: true, name: "Football"},
        {category: "Sporting Goods", price: "$9.99", stocked: true, name: "Baseball"},
        {category: "Sporting Goods", price: "$29.99", stocked: false, name: "Basketball"},
        {category: "Electronics", price: "$99.99", stocked: true, name: "iPod Touch"},
        {category: "Electronics", price: "$399.99", stocked: false, name: "iPhone 5"},
        {category: "Electronics", price: "$199.99", stocked: true, name: "Nexus 7"}
    ];

Step1: UIをコンポーネントの階層構造に落としこむ
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
まず最初に行うのは、モックを形作っている各コンポーネント（構成要素）を囲んで、それぞれに名前を付けていくこと。単一のコンポーネントに括るべき範囲を見つけるための一つの指針に、 **単一責任の原則** がある。これは、新しい関数やオブジェクトをいつ作るのかを決めるときと同じ手法である。

| これ即ち、 **一つのコンポーネントは理想的には一つのことだけをすべきだ** ということである。開発を進める上でコンポーネントが肥大化してしまった場合には、小さなコンポーネントに分割することを検討するべきである。

| JSONのデータモデルをユーザに向けて表示することはよく在る。 **モデルが正しく構築されていれば、UI（つまりはコンポーネントの構造）にもそのデータ構造がうまくマッピングされる** ということが分かるであろう。これは、**UIとデータモデルが同じ情報の構造をもつ傾向が在る** ためである。UIを分割して、それぞれのコンポーネントがデータモデルの、厳密に一部分だけを表現するように落とし込んで見る。

| モック内にコンポーネントを特定できたら、階層構造に並べてみる。モックにおける階層構造を、原則的には、Reactコンポーネントの階層構造にもそのまま移植すれば良い。

Step2: Reactで静的なバージョンを作成する
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
さて、コンポーネントの階層構造が決まったら、アプリの実装に取り掛かる。

| 最初は、データモデルを受け取ってUIの描画だけを行い、ユーザからは操作できないというバージョンを作るのがもっとも簡単であり、またこの工程が重要である。

| **表示の実装とユーザ操作の実装を切り離しておくことは重要である。** 静的な（ユーザが操作できない）バージョンを作る際はコーディングの量が多い代わりに考えることが少なく、ユーザ操作を実装するときには考えることが多い代わりにコーディングの量は少ないからである。概してこのような傾向を持つ。

| データモデルを描画するだけの機能を持った静的なバージョンのアプリを作る際は、他のコンポーネントを再利用しつつそれらにpropsを通じてデータを渡す形で自分のコンポーネントを組み上げていく。propsは親から子へとデータを渡すための手段である。静的なバージョンを作る上では、Reactの流儀として、 **stateを一切つかわないこと。** stateはユーザ操作や時間経過などで動的に変化するデータを扱うために確保されている機能である。そのような関心の分離を徹底していれば、今回のような静的なアプリケーションを実装する際にstateに触れる必要はまったくないことが分かるだろう。

| コンポーネントをコーディングしていくときは、トップダウンで作っても、ボトムアップで作っても問題ない。つまり、高い階層にあるコンポーネント（たとえばFilterableProductTable）から作り始めても、低い階層にあるコンポーネント（ProductRowなど）から作り始めても、どちらでも構わない。それぞれの方式にメリットとデメリットがあり、それらを理解した上で適切な方を選ぶということである。傾向としては、シンプルなアプリでは通常トップダウンで作ったほうが楽なケースが多いが、大きなプロジェクトでは開発をしながらテストを書き、ボトムアップで進めるほうがより簡単である。

| ここまでのステップで、データモデルを描画する再利用可能なコンポーネントのライブラリが手に入る。このアプリは静的なバージョンなので、各コンポーネントはrender()メソッドだけを持つことになる。階層構造の中で最上位のコンポーネント（たとえばFilterableProductTable）が、データモデルをpropsとして受け取ることになるだろう。もととなるデータモデルを更新して再度、ReactDOM.render()を呼び出すと、UIが更新されることになる。このやり方なら、複雑なことをしていないので、UIがどのように更新されて、どこを変更すればよいのか、理解しやすくなる。Reactの単方向データフローにより、全てがモジュール化された高速な状態で保たれる。

Step3: UI状態を表現する必要十分なstateを決定する
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
UIをインタラクティブなものにするために、元となっているデータモデルを更新できるようにする必要が在る。これはReactではstateをつかって実現する。

| 適切に開発を進めていくにあたり、そのアプリに求められている更新可能な状態の最小構成を、最初に考えて決めておくほうが良い。個々で重要なのは、 **DRYの原則** である。 **アプリケーションが必要としている最小限の状態を把握しておき、他に必要なものが出てきたらそのとき計算すれば良いのである** 。たとえば、TODOリストを作る際、TODOの各項目を配列で保持するだけにし、個数のカウント用に別のstate変数を持たないようにする。代わりに、TODOの項目数を表示したいのであれば、配列のlengthゲッターを使えばよい、という考え方である。

| 今回のサンプルアプリを形作る全てのデータについて考えてみる。つぎのようなデータが在る。

- 元となる商品のリスト
- ユーザが入力した検索文字列
- チェックボックスの値
- フィルタ済みの商品のリスト

それぞれについて見ていき、どれがstateになりうるのかを考えてみる。各データについて、３つの問を立ててみる。

1. 親からpropsを通じて与えられたデータか？
2. 時間経過で変化しないままでいるデータか？
3. コンポーネント内にある他のpropsやstateを使って算出可能なデータか？

これらの全てを通過したならば、それはほとんどstateであると言い切ってよいだろう。元となる商品のリストはpropsから渡されるのでこれはstateではない。検索文字列とチェックボックスは時間の経過の中で変化し、また算出することもできないため、stateだと思われる。最後に、フィルタ済みの商品のリストはstateではない。なぜならば、元となる商品のリストと検索文字列とチェックボックスの値を組み合わせることでフィルタ済みの商品のリストを算出することが可能だからである。

| というわけで、stateと呼べるのは次の２つ：

* ユーザが入力した検索文字列
* チェックボックスの値


Step4: stateをどこに配置するべきなのかを明確にする
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
さて、前節の考察でstateの最小構成が明確になった。次は、どのコンポーネントがstateを変化させるのか、つまりはstateを所有するのかを明確にしていく。

アプリの各stateについて、次の項目を確認していく。
* そのstateを使って表示を行う全てのコンポーネントを確認する。
* 共通の親コンポーネントをみつける（その階層構造の中で、あるstateを必要としている全てのコンポーネントの上位にある単一のコンポーネントのことである。）
* 共通の親コンポーネントか、その階層構造でさらに上位の別のコンポーネントがstateを持っているべきである。
* もしstateを持つにふさわしいコンポーネントを見つけられなかった場合は、 **stateを保持するためだけの新しいコンポーネントを作り、** 階層構造の中で既に見つけておいた共通の親コンポーネントの上に配置する。

それでは、この一般的戦略をサンプルアプリにも適用してみる。

- ProductTableは商品リストをフィルタする必要があり、SearchBarは検索文字列とチェック状態を表示する必要が在る。
- 共通の親コンポーネントはFilterableProductTableである。
- 概念的にも、検索文字列とチェック状態がFilterbleProductTableに配置されることは妥当である。

良い感じである。stateをFilterableProductTableの中に配置することが決まった。これが決まれば、あとはFilterableProductTableのconstructorからstateを追加し、filterTextとisStockOnlyをProductTableとSearchBarにpropsとして渡す。最後に、これらのpropsを使ってProductTableのフィルタ処理を行い、SearchBarのフォームにも値を埋める。


Step5: 逆方向のデータフローを追加する
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
ここまでで、propsとstateが階層構造を流れ落ちていく関数として、正しく描画を行うアプリを作ることができた。それでは次に、別の方向のデータフローもサポートしてみることにする。階層構造の奥深くにあるフォームのコンポーネントが、FilterableProductTableにあるstateを更新できるようにする。

| 試しに、現在のバージョンのサンプルで文字を打ち込んだり、チェックボックスを切り替えてみると、Reactがその入力を無視することが分かる。これは意図的な挙動で、inputのprops.valueが、常にFilterableProductTableから渡されたstateと同じ値になるようにセットしてあるのである。

| それでは、どんな挙動に成ってほしいのかを考えてみると、ユーザがフォームを変更するたびにユーザ入力を反映するようにstateを更新したいということになる。コンポーネントのstateを更新できるのは自分自身だけであるべきなので、FilterableProducttableはSearchBarにコールバックを渡しておいて、stateを更新したいときに実行してもらうようにする。入力のキーストロークのたびにコールされるonChangeイベントを利用するとよい。このコールバックを実行されたFilterableProductTabelはsetState()をコールし、その結果としてアプリの状態と描画が更新されるようになる。

終わりに
--------------------------------------------
これで、Reactをつかってコンポーネントやアプリケーションを構築するときの考え方が身についたのではないだろうか。極めて明示的で、極めて明快で、極めて基礎的なモジュール化オブジェクト指向に則ったコーディングであったことが分かればよい。
